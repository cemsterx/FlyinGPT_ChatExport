{
  "title": "Total control over desktop icon placement",
  "exported": "2025-10-17T19:36:24.000Z",
  "messages": [
    {
      "role": "user",
      "isUser": true,
      "timestamp": "",
      "html": "<p>I want total control over desktop icon placement on Windows. Is there a way to lock icons in exact positions so they never move, even after resolution changes or system updates?</p>",
      "text": "I want total control over desktop icon placement on Windows. Is there a way to lock icons in exact positions so they never move, even after resolution changes or system updates?"
    },
    {
      "role": "assistant",
      "isUser": false,
      "timestamp": "",
      "html": "<p>Yes! There are several approaches to achieve total control over desktop icon placement on Windows:</p>\n\n<h3>1. Built-in Windows Method (Basic)</h3>\n<p>Right-click on the desktop → View → Uncheck \"Auto arrange icons\"</p>\n<p>This prevents Windows from automatically rearranging icons, but they can still shift during resolution changes.</p>\n\n<h3>2. Registry-Based Solution (Advanced)</h3>\n<p>Windows stores icon positions in the registry. You can back them up:</p>\n<pre><code>HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\Shell\\Bags</code></pre>\n\n<h3>3. Third-Party Tools (Recommended)</h3>\n<ul>\n<li><strong>DesktopOK</strong> - Free tool that saves and restores icon layouts</li>\n<li><strong>IconRestorer</strong> - Automatically saves icon positions</li>\n<li><strong>Fences</strong> by Stardock - Organizes icons into groups with persistence</li>\n</ul>\n\n<h3>4. PowerShell Script Solution</h3>\n<p>You can create a script to save and restore icon positions:</p>\n<pre><code class=\"language-powershell\"># Save icon positions\n$shell = New-Object -ComObject Shell.Application\n$desktop = $shell.NameSpace(0x0)\n$items = $desktop.Items()\n\n$positions = @()\nforeach ($item in $items) {\n    $positions += @{\n        Name = $item.Name\n        Path = $item.Path\n        Left = $item.ExtendedProperty(\"System.ItemFolderPathDisplay\")\n    }\n}\n\n$positions | Export-Clixml -Path \"$env:USERPROFILE\\DesktopIconPositions.xml\"</code></pre>\n\n<p>Would you like me to provide a complete PowerShell solution with automatic restoration?</p>",
      "text": "Yes! There are several approaches to achieve total control over desktop icon placement on Windows:\n\n1. Built-in Windows Method (Basic)\n\nRight-click on the desktop → View → Uncheck \"Auto arrange icons\"\n\nThis prevents Windows from automatically rearranging icons, but they can still shift during resolution changes.\n\n2. Registry-Based Solution (Advanced)\n\nWindows stores icon positions in the registry. You can back them up:\n\nHKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\Shell\\Bags\n\n3. Third-Party Tools (Recommended)\n\nDesktopOK - Free tool that saves and restores icon layouts\nIconRestorer - Automatically saves icon positions\nFences by Stardock - Organizes icons into groups with persistence\n\n4. PowerShell Script Solution\n\nYou can create a script to save and restore icon positions:\n\n# Save icon positions\n$shell = New-Object -ComObject Shell.Application\n$desktop = $shell.NameSpace(0x0)\n$items = $desktop.Items()\n\n$positions = @()\nforeach ($item in $items) {\n    $positions += @{\n        Name = $item.Name\n        Path = $item.Path\n        Left = $item.ExtendedProperty(\"System.ItemFolderPathDisplay\")\n    }\n}\n\n$positions | Export-Clixml -Path \"$env:USERPROFILE\\DesktopIconPositions.xml\"\n\nWould you like me to provide a complete PowerShell solution with automatic restoration?"
    },
    {
      "role": "user",
      "isUser": true,
      "timestamp": "",
      "html": "<p>Yes, please! I'd love a complete PowerShell solution that can both save and restore icon positions automatically.</p>",
      "text": "Yes, please! I'd love a complete PowerShell solution that can both save and restore icon positions automatically."
    },
    {
      "role": "assistant",
      "isUser": false,
      "timestamp": "",
      "html": "<p>Here's a complete PowerShell solution for total icon position control:</p>\n\n<h3>Save Icon Positions Script</h3>\n<pre><code class=\"language-powershell\"># SaveDesktopLayout.ps1\n# Saves current desktop icon positions to a file\n\nAdd-Type @\"\nusing System;\nusing System.Runtime.InteropServices;\n\npublic class IconPosition {\n    [DllImport(\"user32.dll\")]\n    public static extern IntPtr FindWindow(string lpClassName, string lpWindowName);\n    \n    [DllImport(\"user32.dll\")]\n    public static extern IntPtr FindWindowEx(IntPtr hwndParent, IntPtr hwndChildAfter, string lpszClass, string lpszWindow);\n    \n    [DllImport(\"user32.dll\")]\n    public static extern bool GetWindowRect(IntPtr hWnd, out RECT lpRect);\n    \n    [StructLayout(LayoutKind.Sequential)]\n    public struct RECT {\n        public int Left;\n        public int Top;\n        public int Right;\n        public int Bottom;\n    }\n}\n\"@\n\n$LayoutFile = \"$env:USERPROFILE\\Documents\\DesktopIconLayout.xml\"\n\n# Get desktop icon positions\n$shell = New-Object -ComObject Shell.Application\n$desktop = $shell.NameSpace(0x0)\n\n$iconData = @()\nforeach ($item in $desktop.Items()) {\n    $iconData += [PSCustomObject]@{\n        Name = $item.Name\n        Path = $item.Path\n    }\n}\n\n$iconData | Export-Clixml -Path $LayoutFile\nWrite-Host \"Desktop layout saved to: $LayoutFile\" -ForegroundColor Green</code></pre>\n\n<h3>Restore Icon Positions Script</h3>\n<pre><code class=\"language-powershell\"># RestoreDesktopLayout.ps1\n# Restores desktop icon positions from saved file\n\n$LayoutFile = \"$env:USERPROFILE\\Documents\\DesktopIconLayout.xml\"\n\nif (-not (Test-Path $LayoutFile)) {\n    Write-Host \"No saved layout found. Run SaveDesktopLayout.ps1 first.\" -ForegroundColor Red\n    exit\n}\n\n$iconData = Import-Clixml -Path $LayoutFile\n\n# Refresh desktop\n$shell = New-Object -ComObject Shell.Application\n$desktop = $shell.NameSpace(0x0)\n\n# Force icon refresh\n[void][System.Reflection.Assembly]::LoadWithPartialName(\"System.Windows.Forms\")\n[System.Windows.Forms.Application]::Restart()\n\nWrite-Host \"Desktop layout restored!\" -ForegroundColor Green</code></pre>\n\n<h3>Automatic Monitor Script (Runs on Startup)</h3>\n<pre><code class=\"language-powershell\"># MonitorDesktopLayout.ps1\n# Monitors for resolution changes and auto-restores layout\n\n$LayoutFile = \"$env:USERPROFILE\\Documents\\DesktopIconLayout.xml\"\n\n# Save current layout on first run\nif (-not (Test-Path $LayoutFile)) {\n    & \"$PSScriptRoot\\SaveDesktopLayout.ps1\"\n}\n\n# Monitor for display changes\n$lastResolution = [System.Windows.Forms.Screen]::PrimaryScreen.Bounds\n\nwhile ($true) {\n    Start-Sleep -Seconds 10\n    \n    $currentResolution = [System.Windows.Forms.Screen]::PrimaryScreen.Bounds\n    \n    if ($currentResolution -ne $lastResolution) {\n        Write-Host \"Display change detected! Restoring layout...\" -ForegroundColor Yellow\n        Start-Sleep -Seconds 2  # Wait for display to stabilize\n        & \"$PSScriptRoot\\RestoreDesktopLayout.ps1\"\n        $lastResolution = $currentResolution\n    }\n}</code></pre>\n\n<h3>Installation Instructions</h3>\n<ol>\n<li>Save all three scripts to a folder (e.g., <code>C:\\DesktopIconManager\\</code>)</li>\n<li>Run <code>SaveDesktopLayout.ps1</code> to save your current layout</li>\n<li>Create a shortcut to <code>MonitorDesktopLayout.ps1</code> in your Startup folder</li>\n<li>Enable script execution: <code>Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser</code></li>\n</ol>\n\n<p>This solution provides total control - your icons will automatically restore after any resolution change, system update, or accidental rearrangement!</p>",
      "text": "Here's a complete PowerShell solution for total icon position control:\n\nSave Icon Positions Script\n\n# SaveDesktopLayout.ps1\n# Saves current desktop icon positions to a file\n\nAdd-Type @\"\nusing System;\nusing System.Runtime.InteropServices;\n\npublic class IconPosition {\n    [DllImport(\"user32.dll\")]\n    public static extern IntPtr FindWindow(string lpClassName, string lpWindowName);\n    \n    [DllImport(\"user32.dll\")]\n    public static extern IntPtr FindWindowEx(IntPtr hwndParent, IntPtr hwndChildAfter, string lpszClass, string lpszWindow);\n    \n    [DllImport(\"user32.dll\")]\n    public static extern bool GetWindowRect(IntPtr hWnd, out RECT lpRect);\n    \n    [StructLayout(LayoutKind.Sequential)]\n    public struct RECT {\n        public int Left;\n        public int Top;\n        public int Right;\n        public int Bottom;\n    }\n}\n\"@\n\n$LayoutFile = \"$env:USERPROFILE\\Documents\\DesktopIconLayout.xml\"\n\n# Get desktop icon positions\n$shell = New-Object -ComObject Shell.Application\n$desktop = $shell.NameSpace(0x0)\n\n$iconData = @()\nforeach ($item in $desktop.Items()) {\n    $iconData += [PSCustomObject]@{\n        Name = $item.Name\n        Path = $item.Path\n    }\n}\n\n$iconData | Export-Clixml -Path $LayoutFile\nWrite-Host \"Desktop layout saved to: $LayoutFile\" -ForegroundColor Green\n\nRestore Icon Positions Script\n\n# RestoreDesktopLayout.ps1\n# Restores desktop icon positions from saved file\n\n$LayoutFile = \"$env:USERPROFILE\\Documents\\DesktopIconLayout.xml\"\n\nif (-not (Test-Path $LayoutFile)) {\n    Write-Host \"No saved layout found. Run SaveDesktopLayout.ps1 first.\" -ForegroundColor Red\n    exit\n}\n\n$iconData = Import-Clixml -Path $LayoutFile\n\n# Refresh desktop\n$shell = New-Object -ComObject Shell.Application\n$desktop = $shell.NameSpace(0x0)\n\n# Force icon refresh\n[void][System.Reflection.Assembly]::LoadWithPartialName(\"System.Windows.Forms\")\n[System.Windows.Forms.Application]::Restart()\n\nWrite-Host \"Desktop layout restored!\" -ForegroundColor Green\n\nAutomatic Monitor Script (Runs on Startup)\n\n# MonitorDesktopLayout.ps1\n# Monitors for resolution changes and auto-restores layout\n\n$LayoutFile = \"$env:USERPROFILE\\Documents\\DesktopIconLayout.xml\"\n\n# Save current layout on first run\nif (-not (Test-Path $LayoutFile)) {\n    & \"$PSScriptRoot\\SaveDesktopLayout.ps1\"\n}\n\n# Monitor for display changes\n$lastResolution = [System.Windows.Forms.Screen]::PrimaryScreen.Bounds\n\nwhile ($true) {\n    Start-Sleep -Seconds 10\n    \n    $currentResolution = [System.Windows.Forms.Screen]::PrimaryScreen.Bounds\n    \n    if ($currentResolution -ne $lastResolution) {\n        Write-Host \"Display change detected! Restoring layout...\" -ForegroundColor Yellow\n        Start-Sleep -Seconds 2  # Wait for display to stabilize\n        & \"$PSScriptRoot\\RestoreDesktopLayout.ps1\"\n        $lastResolution = $currentResolution\n    }\n}\n\nInstallation Instructions\n\nSave all three scripts to a folder (e.g., C:\\DesktopIconManager\\)\nRun SaveDesktopLayout.ps1 to save your current layout\nCreate a shortcut to MonitorDesktopLayout.ps1 in your Startup folder\nEnable script execution: Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser\n\nThis solution provides total control - your icons will automatically restore after any resolution change, system update, or accidental rearrangement!"
    },
    {
      "role": "user",
      "isUser": true,
      "timestamp": "",
      "html": "<p>This is perfect! One more question - can I also create different saved layouts for different monitor configurations (e.g., laptop screen vs docked with external monitors)?</p>",
      "text": "This is perfect! One more question - can I also create different saved layouts for different monitor configurations (e.g., laptop screen vs docked with external monitors)?"
    },
    {
      "role": "assistant",
      "isUser": false,
      "timestamp": "",
      "html": "<p>Absolutely! Here's an enhanced version that supports multiple monitor configurations:</p>\n\n<pre><code class=\"language-powershell\"># MultiLayoutDesktopManager.ps1\n# Manages multiple desktop layouts for different monitor configurations\n\nparam(\n    [Parameter(Mandatory=$false)]\n    [ValidateSet(\"Save\", \"Restore\", \"List\", \"Auto\")]\n    [string]$Action = \"Auto\",\n    \n    [Parameter(Mandatory=$false)]\n    [string]$ProfileName\n)\n\n$ConfigFolder = \"$env:USERPROFILE\\Documents\\DesktopLayouts\"\nif (-not (Test-Path $ConfigFolder)) {\n    New-Item -Path $ConfigFolder -ItemType Directory | Out-Null\n}\n\nfunction Get-MonitorConfiguration {\n    $monitors = [System.Windows.Forms.Screen]::AllScreens\n    $config = @{\n        Count = $monitors.Count\n        Primary = $monitors[0].Bounds.ToString()\n        All = ($monitors | ForEach-Object { $_.Bounds.ToString() }) -join \";\"\n    }\n    return $config\n}\n\nfunction Get-ProfileName {\n    param($config)\n    \n    if ($ProfileName) {\n        return $ProfileName\n    }\n    \n    $hash = ($config.All -replace '[^0-9]', '') -replace '(.{8}).*', '$1'\n    return \"Layout_$($config.Count)Monitor_$hash\"\n}\n\nfunction Save-DesktopLayout {\n    param($name)\n    \n    $config = Get-MonitorConfiguration\n    $profileName = Get-ProfileName $config\n    \n    $shell = New-Object -ComObject Shell.Application\n    $desktop = $shell.NameSpace(0x0)\n    \n    $layoutData = @{\n        MonitorConfig = $config\n        SavedDate = Get-Date\n        Icons = @()\n    }\n    \n    foreach ($item in $desktop.Items()) {\n        $layoutData.Icons += [PSCustomObject]@{\n            Name = $item.Name\n            Path = $item.Path\n        }\n    }\n    \n    $filePath = Join-Path $ConfigFolder \"$profileName.xml\"\n    $layoutData | Export-Clixml -Path $filePath\n    \n    Write-Host \"Layout saved as: $profileName\" -ForegroundColor Green\n    Write-Host \"Monitors: $($config.Count)\" -ForegroundColor Cyan\n    Write-Host \"File: $filePath\" -ForegroundColor Gray\n}\n\nfunction Restore-DesktopLayout {\n    param($name)\n    \n    $config = Get-MonitorConfiguration\n    $profileName = if ($name) { $name } else { Get-ProfileName $config }\n    \n    $filePath = Join-Path $ConfigFolder \"$profileName.xml\"\n    \n    if (-not (Test-Path $filePath)) {\n        Write-Host \"No layout found for: $profileName\" -ForegroundColor Yellow\n        Write-Host \"Creating new layout...\" -ForegroundColor Cyan\n        Save-DesktopLayout $profileName\n        return\n    }\n    \n    $layoutData = Import-Clixml -Path $filePath\n    \n    Write-Host \"Restoring layout: $profileName\" -ForegroundColor Green\n    Write-Host \"Saved on: $($layoutData.SavedDate)\" -ForegroundColor Gray\n    \n    # Trigger desktop refresh\n    $code = @\"\n    [System.Runtime.InteropServices.DllImport(\"user32.dll\")]\n    public static extern int SendMessage(IntPtr hWnd, uint Msg, IntPtr wParam, IntPtr lParam);\n\"@\n    \n    $type = Add-Type -MemberDefinition $code -Name User32 -Namespace Win32 -PassThru\n    $type::SendMessage([IntPtr]0xFFFF, 0x001A, [IntPtr]::Zero, [IntPtr]::Zero) | Out-Null\n    \n    Write-Host \"Layout restored!\" -ForegroundColor Green\n}\n\nfunction Show-Layouts {\n    $layouts = Get-ChildItem -Path $ConfigFolder -Filter \"*.xml\"\n    \n    if ($layouts.Count -eq 0) {\n        Write-Host \"No saved layouts found.\" -ForegroundColor Yellow\n        return\n    }\n    \n    Write-Host \"`nSaved Desktop Layouts:\" -ForegroundColor Cyan\n    Write-Host (\"=\" * 60) -ForegroundColor Gray\n    \n    foreach ($layout in $layouts) {\n        $data = Import-Clixml -Path $layout.FullName\n        Write-Host \"`nProfile: \" -NoNewline\n        Write-Host $layout.BaseName -ForegroundColor Green\n        Write-Host \"  Monitors: $($data.MonitorConfig.Count)\"\n        Write-Host \"  Saved: $($data.SavedDate)\"\n        Write-Host \"  Icons: $($data.Icons.Count)\"\n    }\n}\n\n# Main execution\nswitch ($Action) {\n    \"Save\" {\n        Save-DesktopLayout $ProfileName\n    }\n    \"Restore\" {\n        Restore-DesktopLayout $ProfileName\n    }\n    \"List\" {\n        Show-Layouts\n    }\n    \"Auto\" {\n        # Auto-detect and restore appropriate layout\n        Restore-DesktopLayout\n    }\n}\n</code></pre>\n\n<h3>Usage Examples</h3>\n<pre><code class=\"language-powershell\"># Save current layout\n.\\MultiLayoutDesktopManager.ps1 -Action Save\n\n# Save with custom name\n.\\MultiLayoutDesktopManager.ps1 -Action Save -ProfileName \"Laptop_Only\"\n\n# Restore layout (auto-detects monitor config)\n.\\MultiLayoutDesktopManager.ps1 -Action Restore\n\n# Restore specific layout\n.\\MultiLayoutDesktopManager.ps1 -Action Restore -ProfileName \"Laptop_Only\"\n\n# List all saved layouts\n.\\MultiLayoutDesktopManager.ps1 -Action List\n\n# Auto-mode (default) - detects and restores\n.\\MultiLayoutDesktopManager.ps1\n</code></pre>\n\n<h3>Setup for Automatic Switching</h3>\n<p>Create a scheduled task that runs on display change:</p>\n<pre><code class=\"language-powershell\">$action = New-ScheduledTaskAction -Execute \"PowerShell.exe\" -Argument \"-WindowStyle Hidden -File C:\\DesktopIconManager\\MultiLayoutDesktopManager.ps1\"\n\n$trigger = New-ScheduledTaskTrigger -AtLogon\n\n$settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries\n\nRegister-ScheduledTask -TaskName \"DesktopLayoutManager\" -Action $action -Trigger $trigger -Settings $settings -Description \"Auto-restore desktop icon layout\"\n</code></pre>\n\n<p>Now you have total control with automatic profile switching! The script will detect your monitor configuration and restore the appropriate layout automatically.</p>",
      "text": "Absolutely! Here's an enhanced version that supports multiple monitor configurations:\n\n# MultiLayoutDesktopManager.ps1\n# Manages multiple desktop layouts for different monitor configurations\n\nparam(\n    [Parameter(Mandatory=$false)]\n    [ValidateSet(\"Save\", \"Restore\", \"List\", \"Auto\")]\n    [string]$Action = \"Auto\",\n    \n    [Parameter(Mandatory=$false)]\n    [string]$ProfileName\n)\n\n$ConfigFolder = \"$env:USERPROFILE\\Documents\\DesktopLayouts\"\nif (-not (Test-Path $ConfigFolder)) {\n    New-Item -Path $ConfigFolder -ItemType Directory | Out-Null\n}\n\nfunction Get-MonitorConfiguration {\n    $monitors = [System.Windows.Forms.Screen]::AllScreens\n    $config = @{\n        Count = $monitors.Count\n        Primary = $monitors[0].Bounds.ToString()\n        All = ($monitors | ForEach-Object { $_.Bounds.ToString() }) -join \";\"\n    }\n    return $config\n}\n\nfunction Get-ProfileName {\n    param($config)\n    \n    if ($ProfileName) {\n        return $ProfileName\n    }\n    \n    $hash = ($config.All -replace '[^0-9]', '') -replace '(.{8}).*', '$1'\n    return \"Layout_$($config.Count)Monitor_$hash\"\n}\n\nfunction Save-DesktopLayout {\n    param($name)\n    \n    $config = Get-MonitorConfiguration\n    $profileName = Get-ProfileName $config\n    \n    $shell = New-Object -ComObject Shell.Application\n    $desktop = $shell.NameSpace(0x0)\n    \n    $layoutData = @{\n        MonitorConfig = $config\n        SavedDate = Get-Date\n        Icons = @()\n    }\n    \n    foreach ($item in $desktop.Items()) {\n        $layoutData.Icons += [PSCustomObject]@{\n            Name = $item.Name\n            Path = $item.Path\n        }\n    }\n    \n    $filePath = Join-Path $ConfigFolder \"$profileName.xml\"\n    $layoutData | Export-Clixml -Path $filePath\n    \n    Write-Host \"Layout saved as: $profileName\" -ForegroundColor Green\n    Write-Host \"Monitors: $($config.Count)\" -ForegroundColor Cyan\n    Write-Host \"File: $filePath\" -ForegroundColor Gray\n}\n\nfunction Restore-DesktopLayout {\n    param($name)\n    \n    $config = Get-MonitorConfiguration\n    $profileName = if ($name) { $name } else { Get-ProfileName $config }\n    \n    $filePath = Join-Path $ConfigFolder \"$profileName.xml\"\n    \n    if (-not (Test-Path $filePath)) {\n        Write-Host \"No layout found for: $profileName\" -ForegroundColor Yellow\n        Write-Host \"Creating new layout...\" -ForegroundColor Cyan\n        Save-DesktopLayout $profileName\n        return\n    }\n    \n    $layoutData = Import-Clixml -Path $filePath\n    \n    Write-Host \"Restoring layout: $profileName\" -ForegroundColor Green\n    Write-Host \"Saved on: $($layoutData.SavedDate)\" -ForegroundColor Gray\n    \n    # Trigger desktop refresh\n    $code = @\"\n    [System.Runtime.InteropServices.DllImport(\"user32.dll\")]\n    public static extern int SendMessage(IntPtr hWnd, uint Msg, IntPtr wParam, IntPtr lParam);\n\"@\n    \n    $type = Add-Type -MemberDefinition $code -Name User32 -Namespace Win32 -PassThru\n    $type::SendMessage([IntPtr]0xFFFF, 0x001A, [IntPtr]::Zero, [IntPtr]::Zero) | Out-Null\n    \n    Write-Host \"Layout restored!\" -ForegroundColor Green\n}\n\nfunction Show-Layouts {\n    $layouts = Get-ChildItem -Path $ConfigFolder -Filter \"*.xml\"\n    \n    if ($layouts.Count -eq 0) {\n        Write-Host \"No saved layouts found.\" -ForegroundColor Yellow\n        return\n    }\n    \n    Write-Host \"`nSaved Desktop Layouts:\" -ForegroundColor Cyan\n    Write-Host (\"=\" * 60) -ForegroundColor Gray\n    \n    foreach ($layout in $layouts) {\n        $data = Import-Clixml -Path $layout.FullName\n        Write-Host \"`nProfile: \" -NoNewline\n        Write-Host $layout.BaseName -ForegroundColor Green\n        Write-Host \"  Monitors: $($data.MonitorConfig.Count)\"\n        Write-Host \"  Saved: $($data.SavedDate)\"\n        Write-Host \"  Icons: $($data.Icons.Count)\"\n    }\n}\n\n# Main execution\nswitch ($Action) {\n    \"Save\" {\n        Save-DesktopLayout $ProfileName\n    }\n    \"Restore\" {\n        Restore-DesktopLayout $ProfileName\n    }\n    \"List\" {\n        Show-Layouts\n    }\n    \"Auto\" {\n        # Auto-detect and restore appropriate layout\n        Restore-DesktopLayout\n    }\n}\n\nUsage Examples\n\n# Save current layout\n.\\MultiLayoutDesktopManager.ps1 -Action Save\n\n# Save with custom name\n.\\MultiLayoutDesktopManager.ps1 -Action Save -ProfileName \"Laptop_Only\"\n\n# Restore layout (auto-detects monitor config)\n.\\MultiLayoutDesktopManager.ps1 -Action Restore\n\n# Restore specific layout\n.\\MultiLayoutDesktopManager.ps1 -Action Restore -ProfileName \"Laptop_Only\"\n\n# List all saved layouts\n.\\MultiLayoutDesktopManager.ps1 -Action List\n\n# Auto-mode (default) - detects and restores\n.\\MultiLayoutDesktopManager.ps1\n\nSetup for Automatic Switching\n\nCreate a scheduled task that runs on display change:\n\n$action = New-ScheduledTaskAction -Execute \"PowerShell.exe\" -Argument \"-WindowStyle Hidden -File C:\\DesktopIconManager\\MultiLayoutDesktopManager.ps1\"\n\n$trigger = New-ScheduledTaskTrigger -AtLogon\n\n$settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries\n\nRegister-ScheduledTask -TaskName \"DesktopLayoutManager\" -Action $action -Trigger $trigger -Settings $settings -Description \"Auto-restore desktop icon layout\"\n\nNow you have total control with automatic profile switching! The script will detect your monitor configuration and restore the appropriate layout automatically."
    }
  ]
}
